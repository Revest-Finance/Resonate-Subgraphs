// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class BatchInterestClaimed extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save BatchInterestClaimed entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type BatchInterestClaimed must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("BatchInterestClaimed", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): BatchInterestClaimed | null {
    return changetype<BatchInterestClaimed | null>(
      store.get("BatchInterestClaimed", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get poolId(): Bytes {
    let value = this.get("poolId");
    return value!.toBytes();
  }

  set poolId(value: Bytes) {
    this.set("poolId", Value.fromBytes(value));
  }

  get fnftIds(): Array<BigInt> {
    let value = this.get("fnftIds");
    return value!.toBigIntArray();
  }

  set fnftIds(value: Array<BigInt>) {
    this.set("fnftIds", Value.fromBigIntArray(value));
  }

  get claimer(): Bytes {
    let value = this.get("claimer");
    return value!.toBytes();
  }

  set claimer(value: Bytes) {
    this.set("claimer", Value.fromBytes(value));
  }

  get amountInterest(): BigInt {
    let value = this.get("amountInterest");
    return value!.toBigInt();
  }

  set amountInterest(value: BigInt) {
    this.set("amountInterest", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class CapitalActivated extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save CapitalActivated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type CapitalActivated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("CapitalActivated", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): CapitalActivated | null {
    return changetype<CapitalActivated | null>(
      store.get("CapitalActivated", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get poolId(): Bytes {
    let value = this.get("poolId");
    return value!.toBytes();
  }

  set poolId(value: Bytes) {
    this.set("poolId", Value.fromBytes(value));
  }

  get numPackets(): BigInt {
    let value = this.get("numPackets");
    return value!.toBigInt();
  }

  set numPackets(value: BigInt) {
    this.set("numPackets", Value.fromBigInt(value));
  }

  get principalFNFT(): BigInt {
    let value = this.get("principalFNFT");
    return value!.toBigInt();
  }

  set principalFNFT(value: BigInt) {
    this.set("principalFNFT", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class DepositERC20OutputReceiver extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save DepositERC20OutputReceiver entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type DepositERC20OutputReceiver must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DepositERC20OutputReceiver", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): DepositERC20OutputReceiver | null {
    return changetype<DepositERC20OutputReceiver | null>(
      store.get("DepositERC20OutputReceiver", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get mintTo(): Bytes {
    let value = this.get("mintTo");
    return value!.toBytes();
  }

  set mintTo(value: Bytes) {
    this.set("mintTo", Value.fromBytes(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value!.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get amountTokens(): BigInt {
    let value = this.get("amountTokens");
    return value!.toBigInt();
  }

  set amountTokens(value: BigInt) {
    this.set("amountTokens", Value.fromBigInt(value));
  }

  get fnftId(): BigInt {
    let value = this.get("fnftId");
    return value!.toBigInt();
  }

  set fnftId(value: BigInt) {
    this.set("fnftId", Value.fromBigInt(value));
  }

  get extraData(): Bytes {
    let value = this.get("extraData");
    return value!.toBytes();
  }

  set extraData(value: Bytes) {
    this.set("extraData", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class DequeueConsumer extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DequeueConsumer entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type DequeueConsumer must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DequeueConsumer", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): DequeueConsumer | null {
    return changetype<DequeueConsumer | null>(
      store.get("DequeueConsumer", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get poolId(): Bytes {
    let value = this.get("poolId");
    return value!.toBytes();
  }

  set poolId(value: Bytes) {
    this.set("poolId", Value.fromBytes(value));
  }

  get dequeuer(): Bytes {
    let value = this.get("dequeuer");
    return value!.toBytes();
  }

  set dequeuer(value: Bytes) {
    this.set("dequeuer", Value.fromBytes(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value!.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get position(): BigInt {
    let value = this.get("position");
    return value!.toBigInt();
  }

  set position(value: BigInt) {
    this.set("position", Value.fromBigInt(value));
  }

  get order_packetsRemaining(): BigInt {
    let value = this.get("order_packetsRemaining");
    return value!.toBigInt();
  }

  set order_packetsRemaining(value: BigInt) {
    this.set("order_packetsRemaining", Value.fromBigInt(value));
  }

  get order_depositedShares(): BigInt {
    let value = this.get("order_depositedShares");
    return value!.toBigInt();
  }

  set order_depositedShares(value: BigInt) {
    this.set("order_depositedShares", Value.fromBigInt(value));
  }

  get order_owner(): Bytes {
    let value = this.get("order_owner");
    return value!.toBytes();
  }

  set order_owner(value: Bytes) {
    this.set("order_owner", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class DequeueProvider extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DequeueProvider entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type DequeueProvider must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DequeueProvider", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): DequeueProvider | null {
    return changetype<DequeueProvider | null>(
      store.get("DequeueProvider", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get poolId(): Bytes {
    let value = this.get("poolId");
    return value!.toBytes();
  }

  set poolId(value: Bytes) {
    this.set("poolId", Value.fromBytes(value));
  }

  get dequeuer(): Bytes {
    let value = this.get("dequeuer");
    return value!.toBytes();
  }

  set dequeuer(value: Bytes) {
    this.set("dequeuer", Value.fromBytes(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value!.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get position(): BigInt {
    let value = this.get("position");
    return value!.toBigInt();
  }

  set position(value: BigInt) {
    this.set("position", Value.fromBigInt(value));
  }

  get order_packetsRemaining(): BigInt {
    let value = this.get("order_packetsRemaining");
    return value!.toBigInt();
  }

  set order_packetsRemaining(value: BigInt) {
    this.set("order_packetsRemaining", Value.fromBigInt(value));
  }

  get order_depositedShares(): BigInt {
    let value = this.get("order_depositedShares");
    return value!.toBigInt();
  }

  set order_depositedShares(value: BigInt) {
    this.set("order_depositedShares", Value.fromBigInt(value));
  }

  get order_owner(): Bytes {
    let value = this.get("order_owner");
    return value!.toBytes();
  }

  set order_owner(value: Bytes) {
    this.set("order_owner", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class EnqueueConsumer extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save EnqueueConsumer entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type EnqueueConsumer must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("EnqueueConsumer", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): EnqueueConsumer | null {
    return changetype<EnqueueConsumer | null>(
      store.get("EnqueueConsumer", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get poolId(): Bytes {
    let value = this.get("poolId");
    return value!.toBytes();
  }

  set poolId(value: Bytes) {
    this.set("poolId", Value.fromBytes(value));
  }

  get addr(): Bytes {
    let value = this.get("addr");
    return value!.toBytes();
  }

  set addr(value: Bytes) {
    this.set("addr", Value.fromBytes(value));
  }

  get position(): BigInt {
    let value = this.get("position");
    return value!.toBigInt();
  }

  set position(value: BigInt) {
    this.set("position", Value.fromBigInt(value));
  }

  get shouldFarm(): boolean {
    let value = this.get("shouldFarm");
    return value!.toBoolean();
  }

  set shouldFarm(value: boolean) {
    this.set("shouldFarm", Value.fromBoolean(value));
  }

  get order_packetsRemaining(): BigInt {
    let value = this.get("order_packetsRemaining");
    return value!.toBigInt();
  }

  set order_packetsRemaining(value: BigInt) {
    this.set("order_packetsRemaining", Value.fromBigInt(value));
  }

  get order_depositedShares(): BigInt {
    let value = this.get("order_depositedShares");
    return value!.toBigInt();
  }

  set order_depositedShares(value: BigInt) {
    this.set("order_depositedShares", Value.fromBigInt(value));
  }

  get order_owner(): Bytes {
    let value = this.get("order_owner");
    return value!.toBytes();
  }

  set order_owner(value: Bytes) {
    this.set("order_owner", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class EnqueueProvider extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save EnqueueProvider entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type EnqueueProvider must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("EnqueueProvider", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): EnqueueProvider | null {
    return changetype<EnqueueProvider | null>(
      store.get("EnqueueProvider", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get poolId(): Bytes {
    let value = this.get("poolId");
    return value!.toBytes();
  }

  set poolId(value: Bytes) {
    this.set("poolId", Value.fromBytes(value));
  }

  get addr(): Bytes {
    let value = this.get("addr");
    return value!.toBytes();
  }

  set addr(value: Bytes) {
    this.set("addr", Value.fromBytes(value));
  }

  get position(): BigInt {
    let value = this.get("position");
    return value!.toBigInt();
  }

  set position(value: BigInt) {
    this.set("position", Value.fromBigInt(value));
  }

  get shouldFarm(): boolean {
    let value = this.get("shouldFarm");
    return value!.toBoolean();
  }

  set shouldFarm(value: boolean) {
    this.set("shouldFarm", Value.fromBoolean(value));
  }

  get order_packetsRemaining(): BigInt {
    let value = this.get("order_packetsRemaining");
    return value!.toBigInt();
  }

  set order_packetsRemaining(value: BigInt) {
    this.set("order_packetsRemaining", Value.fromBigInt(value));
  }

  get order_depositedShares(): BigInt {
    let value = this.get("order_depositedShares");
    return value!.toBigInt();
  }

  set order_depositedShares(value: BigInt) {
    this.set("order_depositedShares", Value.fromBigInt(value));
  }

  get order_owner(): Bytes {
    let value = this.get("order_owner");
    return value!.toBytes();
  }

  set order_owner(value: Bytes) {
    this.set("order_owner", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class FNFTCreation extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save FNFTCreation entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type FNFTCreation must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("FNFTCreation", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): FNFTCreation | null {
    return changetype<FNFTCreation | null>(
      store.get("FNFTCreation", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get poolId(): Bytes {
    let value = this.get("poolId");
    return value!.toBytes();
  }

  set poolId(value: Bytes) {
    this.set("poolId", Value.fromBytes(value));
  }

  get isPrincipal(): boolean {
    let value = this.get("isPrincipal");
    return value!.toBoolean();
  }

  set isPrincipal(value: boolean) {
    this.set("isPrincipal", Value.fromBoolean(value));
  }

  get fnftId(): BigInt {
    let value = this.get("fnftId");
    return value!.toBigInt();
  }

  set fnftId(value: BigInt) {
    this.set("fnftId", Value.fromBigInt(value));
  }

  get quantityFNFTs(): BigInt {
    let value = this.get("quantityFNFTs");
    return value!.toBigInt();
  }

  set quantityFNFTs(value: BigInt) {
    this.set("quantityFNFTs", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class FNFTRedeemed extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save FNFTRedeemed entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type FNFTRedeemed must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("FNFTRedeemed", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): FNFTRedeemed | null {
    return changetype<FNFTRedeemed | null>(
      store.get("FNFTRedeemed", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get poolId(): Bytes {
    let value = this.get("poolId");
    return value!.toBytes();
  }

  set poolId(value: Bytes) {
    this.set("poolId", Value.fromBytes(value));
  }

  get isPrincipal(): boolean {
    let value = this.get("isPrincipal");
    return value!.toBoolean();
  }

  set isPrincipal(value: boolean) {
    this.set("isPrincipal", Value.fromBoolean(value));
  }

  get fnftId(): BigInt {
    let value = this.get("fnftId");
    return value!.toBigInt();
  }

  set fnftId(value: BigInt) {
    this.set("fnftId", Value.fromBigInt(value));
  }

  get quantityFNFTs(): BigInt {
    let value = this.get("quantityFNFTs");
    return value!.toBigInt();
  }

  set quantityFNFTs(value: BigInt) {
    this.set("quantityFNFTs", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class FeeCollection extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save FeeCollection entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type FeeCollection must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("FeeCollection", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): FeeCollection | null {
    return changetype<FeeCollection | null>(
      store.get("FeeCollection", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get poolId(): Bytes {
    let value = this.get("poolId");
    return value!.toBytes();
  }

  set poolId(value: Bytes) {
    this.set("poolId", Value.fromBytes(value));
  }

  get amountTokens(): BigInt {
    let value = this.get("amountTokens");
    return value!.toBigInt();
  }

  set amountTokens(value: BigInt) {
    this.set("amountTokens", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class InterestClaimed extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save InterestClaimed entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type InterestClaimed must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("InterestClaimed", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): InterestClaimed | null {
    return changetype<InterestClaimed | null>(
      store.get("InterestClaimed", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get poolId(): Bytes {
    let value = this.get("poolId");
    return value!.toBytes();
  }

  set poolId(value: Bytes) {
    this.set("poolId", Value.fromBytes(value));
  }

  get fnftId(): BigInt {
    let value = this.get("fnftId");
    return value!.toBigInt();
  }

  set fnftId(value: BigInt) {
    this.set("fnftId", Value.fromBigInt(value));
  }

  get claimer(): Bytes {
    let value = this.get("claimer");
    return value!.toBytes();
  }

  set claimer(value: Bytes) {
    this.set("claimer", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class OracleRegistered extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OracleRegistered entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type OracleRegistered must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("OracleRegistered", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): OracleRegistered | null {
    return changetype<OracleRegistered | null>(
      store.get("OracleRegistered", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get vaultAsset(): Bytes {
    let value = this.get("vaultAsset");
    return value!.toBytes();
  }

  set vaultAsset(value: Bytes) {
    this.set("vaultAsset", Value.fromBytes(value));
  }

  get paymentAsset(): Bytes {
    let value = this.get("paymentAsset");
    return value!.toBytes();
  }

  set paymentAsset(value: Bytes) {
    this.set("paymentAsset", Value.fromBytes(value));
  }

  get oracleDispatch(): Bytes {
    let value = this.get("oracleDispatch");
    return value!.toBytes();
  }

  set oracleDispatch(value: Bytes) {
    this.set("oracleDispatch", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class OrderWithdrawal extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OrderWithdrawal entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type OrderWithdrawal must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("OrderWithdrawal", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): OrderWithdrawal | null {
    return changetype<OrderWithdrawal | null>(
      store.get("OrderWithdrawal", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get poolId(): Bytes {
    let value = this.get("poolId");
    return value!.toBytes();
  }

  set poolId(value: Bytes) {
    this.set("poolId", Value.fromBytes(value));
  }

  get amountPackets(): BigInt {
    let value = this.get("amountPackets");
    return value!.toBigInt();
  }

  set amountPackets(value: BigInt) {
    this.set("amountPackets", Value.fromBigInt(value));
  }

  get fullyWithdrawn(): boolean {
    let value = this.get("fullyWithdrawn");
    return value!.toBoolean();
  }

  set fullyWithdrawn(value: boolean) {
    this.set("fullyWithdrawn", Value.fromBoolean(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value!.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class OwnershipTransferred extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OwnershipTransferred entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type OwnershipTransferred must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("OwnershipTransferred", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): OwnershipTransferred | null {
    return changetype<OwnershipTransferred | null>(
      store.get("OwnershipTransferred", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class PoolCreated extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PoolCreated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type PoolCreated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PoolCreated", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): PoolCreated | null {
    return changetype<PoolCreated | null>(
      store.get("PoolCreated", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get poolId(): Bytes {
    let value = this.get("poolId");
    return value!.toBytes();
  }

  set poolId(value: Bytes) {
    this.set("poolId", Value.fromBytes(value));
  }

  get asset(): Bytes {
    let value = this.get("asset");
    return value!.toBytes();
  }

  set asset(value: Bytes) {
    this.set("asset", Value.fromBytes(value));
  }

  get vault(): Bytes {
    let value = this.get("vault");
    return value!.toBytes();
  }

  set vault(value: Bytes) {
    this.set("vault", Value.fromBytes(value));
  }

  get payoutAsset(): Bytes {
    let value = this.get("payoutAsset");
    return value!.toBytes();
  }

  set payoutAsset(value: Bytes) {
    this.set("payoutAsset", Value.fromBytes(value));
  }

  get rate(): BigInt {
    let value = this.get("rate");
    return value!.toBigInt();
  }

  set rate(value: BigInt) {
    this.set("rate", Value.fromBigInt(value));
  }

  get addInterestRate(): BigInt {
    let value = this.get("addInterestRate");
    return value!.toBigInt();
  }

  set addInterestRate(value: BigInt) {
    this.set("addInterestRate", Value.fromBigInt(value));
  }

  get lockupPeriod(): BigInt {
    let value = this.get("lockupPeriod");
    return value!.toBigInt();
  }

  set lockupPeriod(value: BigInt) {
    this.set("lockupPeriod", Value.fromBigInt(value));
  }

  get packetSize(): BigInt {
    let value = this.get("packetSize");
    return value!.toBigInt();
  }

  set packetSize(value: BigInt) {
    this.set("packetSize", Value.fromBigInt(value));
  }

  get isFixedTerm(): boolean {
    let value = this.get("isFixedTerm");
    return value!.toBoolean();
  }

  set isFixedTerm(value: boolean) {
    this.set("isFixedTerm", Value.fromBoolean(value));
  }

  get poolName(): string {
    let value = this.get("poolName");
    return value!.toString();
  }

  set poolName(value: string) {
    this.set("poolName", Value.fromString(value));
  }

  get creator(): Bytes {
    let value = this.get("creator");
    return value!.toBytes();
  }

  set creator(value: Bytes) {
    this.set("creator", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class VaultAdapterRegistered extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save VaultAdapterRegistered entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type VaultAdapterRegistered must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("VaultAdapterRegistered", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): VaultAdapterRegistered | null {
    return changetype<VaultAdapterRegistered | null>(
      store.get("VaultAdapterRegistered", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get underlyingVault(): Bytes {
    let value = this.get("underlyingVault");
    return value!.toBytes();
  }

  set underlyingVault(value: Bytes) {
    this.set("underlyingVault", Value.fromBytes(value));
  }

  get vaultAdapter(): Bytes {
    let value = this.get("vaultAdapter");
    return value!.toBytes();
  }

  set vaultAdapter(value: Bytes) {
    this.set("vaultAdapter", Value.fromBytes(value));
  }

  get vaultAsset(): Bytes {
    let value = this.get("vaultAsset");
    return value!.toBytes();
  }

  set vaultAsset(value: Bytes) {
    this.set("vaultAsset", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class WithdrawERC20OutputReceiver extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save WithdrawERC20OutputReceiver entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type WithdrawERC20OutputReceiver must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set(
        "WithdrawERC20OutputReceiver",
        id.toBytes().toHexString(),
        this
      );
    }
  }

  static load(id: Bytes): WithdrawERC20OutputReceiver | null {
    return changetype<WithdrawERC20OutputReceiver | null>(
      store.get("WithdrawERC20OutputReceiver", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get caller(): Bytes {
    let value = this.get("caller");
    return value!.toBytes();
  }

  set caller(value: Bytes) {
    this.set("caller", Value.fromBytes(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value!.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get amountTokens(): BigInt {
    let value = this.get("amountTokens");
    return value!.toBigInt();
  }

  set amountTokens(value: BigInt) {
    this.set("amountTokens", Value.fromBigInt(value));
  }

  get fnftId(): BigInt {
    let value = this.get("fnftId");
    return value!.toBigInt();
  }

  set fnftId(value: BigInt) {
    this.set("fnftId", Value.fromBigInt(value));
  }

  get extraData(): Bytes {
    let value = this.get("extraData");
    return value!.toBytes();
  }

  set extraData(value: Bytes) {
    this.set("extraData", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class PriceProviderOwnershipTransferred extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save PriceProviderOwnershipTransferred entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type PriceProviderOwnershipTransferred must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set(
        "PriceProviderOwnershipTransferred",
        id.toBytes().toHexString(),
        this
      );
    }
  }

  static load(id: Bytes): PriceProviderOwnershipTransferred | null {
    return changetype<PriceProviderOwnershipTransferred | null>(
      store.get("PriceProviderOwnershipTransferred", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class SetTokenOracle extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SetTokenOracle entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type SetTokenOracle must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SetTokenOracle", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): SetTokenOracle | null {
    return changetype<SetTokenOracle | null>(
      store.get("SetTokenOracle", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value!.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get oracle(): Bytes {
    let value = this.get("oracle");
    return value!.toBytes();
  }

  set oracle(value: Bytes) {
    this.set("oracle", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}
